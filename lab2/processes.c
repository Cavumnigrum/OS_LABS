#include <stdio.h>      // Библиотека для ввода-вывода (printf)
#include <stdlib.h>     // Библиотека для system(), exit()
#include <unistd.h>     // Библиотека для fork(), getpid(), getppid(), sleep()
#include <sys/types.h>  // Определения типов процессов
#include <sys/wait.h>   // Библиотека для wait()
#include <time.h>       // Библиотека для работы со временем

// Функция для получения и вывода текущего времени в формате "часы:минуты:секунды"
void print_time() {
    time_t t;                   // Переменная для хранения времени
    struct tm *tm_info;         // Структура для хранения локального времени
    char time_buffer[9];         // Буфер для форматированной строки времени

    time(&t);                    // Получаем текущее время
    tm_info = localtime(&t);     // Преобразуем его в локальное время
    strftime(time_buffer, 9, "%H:%M:%S", tm_info); // Форматируем в "часы:минуты:секунды"
    printf("Текущее время: %s\n", time_buffer);  // Выводим время
}

int main() {
    pid_t pid1, pid2;  // Переменные для хранения идентификаторов процессов

    // Вывод информации о родительском процессе
    printf("Родительский процесс: PID=%d, PPID=%d\n", getpid(), getppid());
    print_time();  // Выводим текущее время

    // Создаём первый дочерний процесс
    pid1 = fork();
    if (pid1 == 0) { // Дочерний процесс получает 0 в результате вызова fork()
        // Первый дочерний процесс
        printf("Первый дочерний процесс: PID=%d, PPID=%d\n", getpid(), getppid());
        print_time();

        // Сортировка файлов домашней директории по времени доступа
        printf("\nСодержимое домашней директории, отсортированное по времени доступа:\n");
        system("ls -ltu ~");  // ls -ltu: сортировка по времени последнего доступа

        exit(0);  // Завершаем работу первого дочернего процесса
    }

    // Создаём второй дочерний процесс
    pid2 = fork();
    if (pid2 == 0) { // Второй дочерний процесс также получает 0
        // Второй дочерний процесс
        printf("Второй дочерний процесс: PID=%d, PPID=%d\n", getpid(), getppid());
        print_time();
        exit(0);  // Завершаем второй дочерний процесс
    }

    // Родительский процесс ожидает, чтобы дочерние процессы успели выполнить код
    sleep(1);

    // Вывод списка всех запущенных процессов в системе (включая созданные нами)
    printf("\nВывод команды ps -x:\n");
    system("ps -x");  // Выполняем команду ps -x (список всех процессов пользователя)

    // Ожидание завершения обоих дочерних процессов
    wait(NULL);  // Ожидание завершения первого дочернего процесса
    wait(NULL);  // Ожидание завершения второго дочернего процесса

    return 0;  // Завершаем работу программы
}
