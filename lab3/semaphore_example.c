#include <stdio.h>      // для работы с файлами: fopen, fprintf, fclose
#include <stdlib.h>     // для стандартных функций: exit, etc.
#include <sys/ipc.h>    // для создания IPC-ключей (ftok)
#include <sys/sem.h>    // для работы с семафорами: semget, semop, semctl
#include <unistd.h>     // для функций getpid(), sleep()
#include <fcntl.h>      // для touch-файла

// Операция "занять семафор" (Down / P-операция)
// Блокирует, если значение семафора уже 0
void sem_down(int semid) {
    struct sembuf sb = {0, -1, 0}; // номер семафора в массиве: 0, операция: -1 (уменьшить), флаги: 0
    semop(semid, &sb, 1);          // выполнить одну операцию на семафоре
}

// Операция "освободить семафор" (Up / V-операция)
void sem_up(int semid) {
    struct sembuf sb = {0, 1, 0};  // операция: +1 (освободить)
    semop(semid, &sb, 1);          // выполнить одну операцию на семафоре
}

int main() {
    // Создаём уникальный ключ для идентификации семафора.
    // "file" — это существующий файл в директории. 65 — произвольный номер.
    key_t key = ftok("file", 65);

    // Получаем ID семафора (или создаём его, если не существует)
    // 1 — создаём массив из одного семафора
    // 0666 — права доступа rw-rw-rw-, IPC_CREAT — флаг создания
    int semid = semget(key, 1, 0666 | IPC_CREAT);

    // Устанавливаем начальное значение семафора в 1 (разрешён один доступ одновременно)
    semctl(semid, 0, SETVAL, 1);

    // 5 раз пытаемся записать в файл
    for (int i = 0; i < 5; i++) {
        sem_down(semid); // заблокировать семафор (возможно, подождать)

        // Критическая секция: запись в общий файл
        FILE *f = fopen("shared.txt", "a"); // открыть файл в режиме дозаписи
        fprintf(f, "PID %d: запись %d\n", getpid(), i); // записать PID и номер итерации
        fclose(f); // закрыть файл

        sem_up(semid); // освободить семафор (разблокировать)
    }

    return 0;
}
